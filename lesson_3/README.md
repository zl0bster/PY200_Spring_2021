# Практическое задание

Используя реализованный на лекции класс **`Node`** реализовать магические матоды для класса **`LinkedList`**, 
чтобы работать с ним как с последовательностью:
- **`__str__`**
- **`__repr__`**
- **`__getitem__`**
- **`__setitem__`** 
- **`__len__`**

1. Метод **`__getitem__`** должен работать аналогично встроенному типу `list`. 
А именно обращение только по числовым индексам
    > TypeError: list indices must be integers or slices, not ...
2. В методе **`__getitem__`** обязательно должна присутствовать проверка **`IndexError`**, 
иначе [метод не сможет работать](https://colab.research.google.com/drive/1grVQ0zHUgE5ufVqH4PNxlr-6SZEw83KQ#scrollTo=jhsrEtxJDfxZ)
с циклом `for`.
3. Метод **`__setitem__`** должен устанавливать новое значение в указанном узле. 
Обращение может быть только ко числовым индексам.
4. Проверить работу **`LinkedList`** 
    - c циклом `for`
    - оператором `in` и `not in`
    - функцией `sorted()`
5. Метод **`to_list`** реализовать через list comprehension.
6. Переделать метод **`__str__`** и **`__repr__`** с учетом того, что теперь **`LinkedList`** итерируемый объект.
    - для **`__str__` должно выводиться строка `[item0, item2, ..., item_n]`
    - для **`__repr__` должно выводиться строка `LinkedList([item0, item2, ..., item_n])`
7. Реализовать метод **`insert`**. Рассмотреть три случая вставка в начало, середину и конец.
8. Реализовать метод **`clear`**. Метод очиски связанного списка должен быть оформлен в одну строку с 
удалением всех узлов списка.

# Домашнее задание
1. Реализовать следующие методы:
    - **`index`**. При отсутсвии значения в списке генерировать ошибку формата:
        > ValueError: 1 is not in list
    - **`remove`**. При отсутсвии удаляемого элемента должна генерироваться ошибка формата
        > ValueError: list.remove(x): x not in list
    - **`sort`**. Данный метод должен изменять сам список, а не возвращать его копию
2. Реализовать метод **`is_iterable`**, который будет проверять наличение в указанном объекте метода **`__iter__`**.
Примите во внимание, что метод это тоже атрибут, а для проверки наличия атрибутов, есть специальная функция.
3. В методе **`append`** используя атрибут **`self.tail`** , который всегда хранит последний узел, переделать данный 
метод с целью ускорения его работы, а именно снижения временной сложности с O(n) -> O(1).

# Задания для дополнительной самостоятельной работы
1. Реализовать для **`LinkedList`** магический метод **`__reversed__`**
2. Создать класс **`KMPstring`**, который будет наследоваться от встроеннго класса **`str`**, который отвечает за строки
в Python. В дочернем классе переопределить метод **`__contains__`**, который будет искать вхождение подстроки в строке с 
помощью алгоритма Кнута — Морриса — Пратта.




    




