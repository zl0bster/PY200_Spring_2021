# Рабочий файл с лекции
https://github.com/aeksei/PY200_Spring_2021/blob/master/lesson_4/lesson_4.ipynb

# Практическое задание

<details><summary>**1_iter_dict.py**</summary>
<p>

Сделать свою реализацию словаря, в котором будет переопределен метод __iter__,
чтобы он возвращал итератор не по ключам, а сразу по паре ключ, значение.

Используйте наследование от встроеного типа dict, и полиморфизм для метода __iter__.
Конструктор базового класса переопределять не нужно.

Чтобы получить пары ключ-значение используйте либо метод базового self.items() либо
функцию zip() для self.keys() и self.values()

</p>
</details>

<details><summary>**2_linked_list_iter.py**</summary>
<p>

Выбрать экземпляры класса LinkedList будут итераторами или итерируемыми объектами.
и уметь обосновать(!) это (https://colab.research.google.com/drive/12UErjm9lm31DPEFSxcyrH47LUX5oRwyH#scrollTo=z_-otPpGrQTs)

В соответвии с понятным и знакомым выбранным решением реализовать соответвующие методы.
Можно пользоваться любыми готовыми итераторами, функциями-генераторами, самостоятельно реализовывать метод __next__.

</p>
</details>

<details><summary>**3_linked_list_clear.py**</summary>
<p>

Взять класс LinkedList и определить для него соответвующие методы очистки списка от объектов Node.

    1. Перегрузить в классе Node метод __del__, чтобы видеть сообщение о том, что текущий объект удален
    2. Используя встроенную функцию sys.getrefcount() от каждого узла списка получить информацию о количестве
        переменных, которые ссылаются на данный объект. Прокоментировать и рассказать откуда берется каждая ссылка.
        см. Алгоритм подсчета ссылок https://colab.research.google.com/drive/12UErjm9lm31DPEFSxcyrH47LUX5oRwyH#scrollTo=jxYLDA_KDPv6
    3. Реализовать метод **`clear`**. Метод очиски связанного списка должен быть оформлен в одну строку с
        удалением всех узлов списка.

</p>
</details>

<details><summary>**4_double_linked_nodes.py**</summary>
<p>

Сделать DoubleLinkedNode наследуясь от класса Node

    1. В конструкторе DoubleLinkedNode обязательно вызвать конструктор базоваго класса и определить дополнительный
        атрибут self.prev, хранящий в себе ссылку на предыдущий узел. Тем сымым дополняя функциональность базового класса,
        сохраняя его логику.
    2. Атрибут экземпляра prev сделать свойством prev. Определить для него getter и setter c проверками аналогичными
        свойству next в класса Node.
    3. В классе Node вынести проверку присваемого узла в setter свойства next во внутренний метод.
        Данный метод должен быть внутренним и не доступным пользователю.
    4. В классе DoubleLinkedNode воспользоваться методом из прошлого шага, чтобы проверить setter свойства prev.
        Каким должен быть этот метод?
            - protected
            - private
    5. Для DoubleLinkedNode перегрузить метод __repr__, метод __str__ оставить без изменений.


</p>
</details>

<details><summary>**5_double_linked_list.py**</summary>
<p>

Двусвязный список на основе односвязного списка.

    Самостоятельное задание. В двусвязном списке должны быть следующие методы:
    - **`__str__`**
    - **`__repr__`**
    - **`__getitem__`**
    - **`__setitem__`**
    - **`__len__`**
    - **`insert`**
    - **`index`**
    - **`remove`**
    - **`append`**
    - **`__iter__`**

    Необязательно все эти методы должны быть переопределены в явном виде. По максимуму используйте
    наследование, если поведение списков в контексте реализации указанных метод схоже.
    С точки зрения наследования по минимуму перегружайте методы. При необходимости рефакторите базовый класс,
    чтобы локализовать части кода во вспомогательные функции, которые имеют различное поведение
    в связном и двусвязном списках.
    Стремитесь к минимизации кода в дочернем классе.

    Есть какой-то метод класса DoubleLinkedList хотите отработать в явном виде ещё раз, не возбраняется.

</p>
</details>

# Домашнее задание
1. Реализовать двусвязный список

# Задания для дополнительной самостоятельной работы
